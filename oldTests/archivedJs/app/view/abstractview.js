// Generated by CoffeeScript 1.7.1
(function() {
  define([], function() {
    var AbstractView;
    AbstractView = (function() {
      var DEG_TO_RAD, RAD_TO_DEG;

      function AbstractView() {}

      AbstractView.prototype.renderInitialView = function(pair) {
        return console.log("renderInitialView not implemented for [" + this.constructor.name + "]");
      };

      AbstractView.prototype.showNextPair = function(pair) {
        return console.log("showNextPair not implemented for [" + this.constructor.name + "]");
      };

      AbstractView.prototype.pseudoDestructor = function() {
        return console.log("pseudoDestructor::[" + this.constructor.name + "]");
      };

      AbstractView.prototype.clipElement = function(points, imgToClip, svgUrlId) {
        var path;
        if (imgToClip.length > 0) {
          path = this.translatePointsFromArrayToWebkitString(points);
          imgToClip.css("clip-path", "url('#" + svgUrlId + "')");
          return imgToClip.css("-webkit-clip-path", path);
        }
      };

      AbstractView.prototype.translatePointsFromArrayToWebkitString = function(points) {
        var i, p, rv, x, y, _i, _len;
        rv = "polygon(";
        for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
          p = points[i];
          x = p[0], y = p[1];
          rv += (i === 0 ? "" : ", ") + x + "px " + y + "px";
        }
        rv += ")";
        return rv;
      };

      AbstractView.prototype.translatePointsFromArrayToSVGNotation = function(points) {
        var i, p, rv, x, y, _i, _len;
        rv = "";
        for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
          p = points[i];
          x = p[0], y = p[1];
          rv += (i === 0 ? "" : ",") + x + " " + y;
        }
        return rv;
      };

      DEG_TO_RAD = Math.PI / 180;

      RAD_TO_DEG = 180 / Math.PI;

      AbstractView.prototype.createClippingPolygons = function(imgWidth, imgHeight, topEdgeInset, bottomEdgeInset, textBoxHeight) {
        var bottomAngle, insetDiff, leftImagePoly, leftTextPoly, rightImagePoly, rightTextPoly, textTriangleBase, topAngle;
        leftImagePoly = [[0, 0], [imgWidth - topEdgeInset, 0], [imgWidth - bottomEdgeInset, imgHeight], [0, imgHeight]];
        rightImagePoly = [[bottomEdgeInset, 0], [imgWidth, 0], [imgWidth, imgHeight], [topEdgeInset, imgHeight]];
        insetDiff = Math.abs(topEdgeInset - bottomEdgeInset);
        bottomAngle = Math.atan(imgHeight / insetDiff) * RAD_TO_DEG;
        topAngle = Math.atan(insetDiff / imgHeight) * RAD_TO_DEG;
        console.log("angles are [" + bottomAngle + "] / [" + topAngle + "]");
        textTriangleBase = textBoxHeight / Math.tan(bottomAngle * DEG_TO_RAD);
        leftTextPoly = [[0, 0], [imgWidth - bottomEdgeInset + textTriangleBase, 0], [imgWidth - bottomEdgeInset, textBoxHeight], [0, textBoxHeight]];
        rightTextPoly = [[topEdgeInset + textTriangleBase, 0], [imgWidth, 0], [imgWidth, textBoxHeight], [topEdgeInset, textBoxHeight]];
        return [leftImagePoly, rightImagePoly, leftTextPoly, rightTextPoly];
      };

      AbstractView.prototype.stackElements = function(elementA, elementB) {
        var bottomIdx, topIdx, zA, zB;
        zA = 2;
        zB = 1;
        topIdx = Math.max(zA, zB);
        bottomIdx = Math.min(zA, zB);
        if (topIdx === bottomIdx) {
          topIdx++;
        }
        elementA.css("z-index", topIdx);
        return elementB.css("z-index", bottomIdx);
      };

      return AbstractView;

    })();
    return AbstractView;
  });

}).call(this);
